<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>PixelPlacer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            /* Prevent touch behaviors on iOS/iPad */
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            /* Prevent pull-to-refresh and overscroll */
            overscroll-behavior: none;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            /* Prevent touch behaviors */
            touch-action: none;
        }

        /* Loading screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: #fff;
        }

        #loading.hidden {
            display: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #333;
            border-top-color: #0af;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #loading-text {
            font-size: 14px;
            color: #888;
        }

        #progress-container {
            width: 200px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }

        #progress-bar {
            width: 0%;
            height: 100%;
            background: #0af;
            transition: width 0.3s ease;
        }

        /* Hidden file input for open dialog */
        #file-input {
            display: none;
        }

        /* Hidden download anchor */
        #download-anchor {
            display: none;
        }

    </style>
</head>
<body>
    <!-- Loading screen -->
    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading PixelPlacer...</div>
        <div id="progress-container">
            <div id="progress-bar"></div>
        </div>
    </div>

    <!-- Main canvas -->
    <div id="canvas-container">
        <canvas id="canvas" tabindex="0"></canvas>
    </div>

    <!-- Hidden elements for file operations -->
    <input type="file" id="file-input" accept="image/*,.pp">
    <a id="download-anchor"></a>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false, willReadFrequently: false });

        // Track if we need to prevent default on events
        let wasmReady = false;

        // Resize canvas to fill window with HiDPI support
        let currentDpr = window.devicePixelRatio || 1;

        function resizeCanvas() {
            currentDpr = window.devicePixelRatio || 1;
            const cssWidth = window.innerWidth;
            const cssHeight = window.innerHeight;

            // Canvas buffer at physical pixel size for sharp rendering
            const bufferWidth = Math.round(cssWidth * currentDpr);
            const bufferHeight = Math.round(cssHeight * currentDpr);

            canvas.width = bufferWidth;
            canvas.height = bufferHeight;
            canvas.style.width = cssWidth + 'px';
            canvas.style.height = cssHeight + 'px';

            // Notify WASM of physical dimensions to match canvas buffer
            if (wasmReady && Module._wasm_push_resize_event) {
                Module._wasm_push_resize_event(bufferWidth, bufferHeight);
            }
        }

        // Mouse button mapping
        function getMouseButton(e) {
            switch (e.button) {
                case 0: return 1;  // Left
                case 1: return 2;  // Middle
                case 2: return 3;  // Right
                default: return 1;
            }
        }

        // Key modifier flags
        function getModifiers(e) {
            let mods = 0;
            if (e.shiftKey) mods |= 1;
            if (e.ctrlKey) mods |= 2;
            if (e.altKey) mods |= 4;
            if (e.metaKey) mods |= 8;
            return mods;
        }

        // Event listeners - scale coordinates by DPR to match physical pixel buffer
        canvas.addEventListener('mousedown', (e) => {
            if (!wasmReady) return;
            e.preventDefault();
            canvas.focus();
            const x = Math.round(e.offsetX * currentDpr);
            const y = Math.round(e.offsetY * currentDpr);
            Module._wasm_push_mouse_event(0, x, y, getMouseButton(e), getModifiers(e));
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!wasmReady) return;
            e.preventDefault();
            const x = Math.round(e.offsetX * currentDpr);
            const y = Math.round(e.offsetY * currentDpr);
            Module._wasm_push_mouse_event(1, x, y, getMouseButton(e), getModifiers(e));

        });

        canvas.addEventListener('mousemove', (e) => {
            if (!wasmReady) return;
            const x = Math.round(e.offsetX * currentDpr);
            const y = Math.round(e.offsetY * currentDpr);
            Module._wasm_push_mouse_event(2, x, y, 0, getModifiers(e));
        });

        canvas.addEventListener('wheel', (e) => {
            if (!wasmReady) return;
            e.preventDefault();
            // Normalize wheel delta
            let delta = e.deltaY;
            if (e.deltaMode === 1) delta *= 20;  // Line mode
            else if (e.deltaMode === 2) delta *= 100;  // Page mode
            delta = Math.sign(delta) * Math.min(Math.abs(delta), 100);
            const x = Math.round(e.offsetX * currentDpr);
            const y = Math.round(e.offsetY * currentDpr);
            Module._wasm_push_wheel_event(x, y, -Math.round(delta / 10), getModifiers(e));
        }, { passive: false });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Touch events - map to mouse events with pressure support
        let activeTouchId = null;

        canvas.addEventListener('touchstart', (e) => {
            if (!wasmReady) return;
            e.preventDefault();

            // Only track the first touch
            if (activeTouchId !== null) return;

            const touch = e.changedTouches[0];
            activeTouchId = touch.identifier;

            const rect = canvas.getBoundingClientRect();
            const x = Math.round((touch.clientX - rect.left) * currentDpr);
            const y = Math.round((touch.clientY - rect.top) * currentDpr);

            // Get pressure (force) - ranges from 0 to 1, default to 0.5 if not supported
            let pressure = 0.5;
            if (touch.force !== undefined && touch.force > 0) {
                pressure = touch.force;
            }

            Module._wasm_push_touch_event(0, x, y, pressure);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (!wasmReady) return;
            e.preventDefault();

            // Find our tracked touch
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (touch.identifier === activeTouchId) {
                    const rect = canvas.getBoundingClientRect();
                    const x = Math.round((touch.clientX - rect.left) * currentDpr);
                    const y = Math.round((touch.clientY - rect.top) * currentDpr);

                    let pressure = 0.5;
                    if (touch.force !== undefined && touch.force > 0) {
                        pressure = touch.force;
                    }

                    Module._wasm_push_touch_event(2, x, y, pressure);
                    break;
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (!wasmReady) return;
            e.preventDefault();

            // Find our tracked touch
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (touch.identifier === activeTouchId) {
                    const rect = canvas.getBoundingClientRect();
                    const x = Math.round((touch.clientX - rect.left) * currentDpr);
                    const y = Math.round((touch.clientY - rect.top) * currentDpr);

                    Module._wasm_push_touch_event(1, x, y, 0);
                    activeTouchId = null;
                    break;
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchcancel', (e) => {
            if (!wasmReady) return;
            e.preventDefault();

            // Treat cancel as touch end
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                if (touch.identifier === activeTouchId) {
                    const rect = canvas.getBoundingClientRect();
                    const x = Math.round((touch.clientX - rect.left) * currentDpr);
                    const y = Math.round((touch.clientY - rect.top) * currentDpr);

                    Module._wasm_push_touch_event(1, x, y, 0);
                    activeTouchId = null;
                    break;
                }
            }
        }, { passive: false });

        // Keyboard events
        canvas.addEventListener('keydown', (e) => {
            if (!wasmReady) return;

            // Don't prevent default for browser shortcuts we want to allow
            const allowDefault = (e.ctrlKey || e.metaKey) && ['r', 'w', 't', 'n'].includes(e.key.toLowerCase());
            if (!allowDefault) {
                e.preventDefault();
            }

            Module._wasm_push_key_event(0, e.keyCode, e.code ? e.code.charCodeAt(0) : 0, getModifiers(e), e.repeat ? 1 : 0);

            // Handle text input for printable characters
            if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
                const ptr = Module.stringToNewUTF8(e.key);
                Module._wasm_push_text_input(ptr);
                Module._free(ptr);
            }
        });

        canvas.addEventListener('keyup', (e) => {
            if (!wasmReady) return;
            e.preventDefault();
            Module._wasm_push_key_event(1, e.keyCode, e.code ? e.code.charCodeAt(0) : 0, getModifiers(e), 0);
        });

        // Drag and drop
        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        canvas.addEventListener('drop', async (e) => {
            e.preventDefault();
            if (!wasmReady) return;

            const file = e.dataTransfer.files[0];
            if (file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const data = new Uint8Array(arrayBuffer);

                    // Allocate WASM memory and copy data
                    const ptr = Module._malloc(data.length);
                    HEAPU8.set(data, ptr);

                    // Send file data to C++
                    const namePtr = stringToNewUTF8(file.name);
                    Module._wasm_receive_file_data(ptr, data.length, namePtr);
                    Module._free(namePtr);
                    Module._free(ptr);

                    // Also notify via the drop event
                    const pathPtr = stringToNewUTF8(file.name);
                    Module._wasm_push_file_drop(pathPtr);
                    Module._free(pathPtr);
                } catch (err) {
                    console.error('Drop error:', err);
                }
            }
        });

        // Window resize
        window.addEventListener('resize', resizeCanvas);

        // File input is handled by C++ platform code via EM_ASM

        console.log('Setting up Emscripten Module...');

        // Emscripten Module configuration
        var Module = {
            preRun: [],
            postRun: [],
            print: function(text) {
                console.log(text);
            },
            printErr: function(text) {
                console.error(text);
            },
            canvas: canvas,
            setStatus: function(text) {
                const loadingText = document.getElementById('loading-text');
                if (loadingText) {
                    loadingText.textContent = text || 'Loading...';
                }

                // Parse progress if available
                const match = text.match(/(\d+)\/(\d+)/);
                if (match) {
                    const progress = (parseInt(match[1]) / parseInt(match[2])) * 100;
                    document.getElementById('progress-bar').style.width = progress + '%';
                }
            },
            totalDependencies: 0,
            monitorRunDependencies: function(left) {
                this.totalDependencies = Math.max(this.totalDependencies, left);
                if (this.totalDependencies > 0) {
                    const progress = ((this.totalDependencies - left) / this.totalDependencies) * 100;
                    document.getElementById('progress-bar').style.width = progress + '%';
                }
            },
            onRuntimeInitialized: function() {
                // Initialize canvas size
                resizeCanvas();

                // Hide loading screen
                document.getElementById('loading').classList.add('hidden');

                // Focus canvas
                canvas.focus();

                // Mark WASM as ready
                wasmReady = true;

                console.log('PixelPlacer WASM initialized');
            }
        };

        // JavaScript functions called from C++
        // Cached ImageData to avoid allocation every frame
        let cachedImageData = null;
        let cachedWidth = 0;
        let cachedHeight = 0;

        window.js_render_frame = function(pixelPtr, width, height) {
            // Only resize canvas and recreate ImageData when dimensions change
            if (cachedWidth !== width || cachedHeight !== height) {
                canvas.width = width;
                canvas.height = height;
                cachedImageData = ctx.createImageData(width, height);
                cachedWidth = width;
                cachedHeight = height;
            }

            const dst = cachedImageData.data;
            const pixelCount = width * height;
            const requiredBytes = pixelPtr + pixelCount * 4;

            // Check bounds before accessing heap
            if (requiredBytes > HEAPU8.length) {
                console.error('js_render_frame: heap access out of bounds!',
                    'pixelPtr:', pixelPtr,
                    'size:', width, 'x', height,
                    'required:', requiredBytes,
                    'heapSize:', HEAPU8.length);
                return;
            }

            // Direct copy - C++ now stores in canvas RGBA byte order
            dst.set(HEAPU8.subarray(pixelPtr, pixelPtr + pixelCount * 4));
            ctx.putImageData(cachedImageData, 0, 0);
        };

        // Cached partial ImageData to avoid allocation every partial update
        let partialImageData = null;
        let partialCachedWidth = 0;
        let partialCachedHeight = 0;

        // Partial frame rendering - only update a dirty region
        window.js_render_frame_partial = function(pixelPtr, width, height, dx, dy, dw, dh) {
            // Ensure canvas dimensions match
            if (cachedWidth !== width || cachedHeight !== height) {
                // Dimensions changed, fall back to full render
                js_render_frame(pixelPtr, width, height);
                return;
            }

            // Clamp dirty region to canvas bounds
            if (dx < 0) { dw += dx; dx = 0; }
            if (dy < 0) { dh += dy; dy = 0; }
            if (dx + dw > width) dw = width - dx;
            if (dy + dh > height) dh = height - dy;
            if (dw <= 0 || dh <= 0) return;

            // Reuse cached ImageData if size matches, otherwise reallocate
            if (partialCachedWidth !== dw || partialCachedHeight !== dh) {
                partialImageData = ctx.createImageData(dw, dh);
                partialCachedWidth = dw;
                partialCachedHeight = dh;
            }
            const dst = partialImageData.data;

            // Copy only the dirty region from the framebuffer
            for (let y = 0; y < dh; y++) {
                const srcRowStart = pixelPtr + ((dy + y) * width + dx) * 4;
                const dstRowStart = y * dw * 4;
                dst.set(HEAPU8.subarray(srcRowStart, srcRowStart + dw * 4), dstRowStart);
            }

            ctx.putImageData(partialImageData, dx, dy);
        };

        // Helper functions are called from C++ via EM_ASM directly
        // No need for window.js_* wrappers anymore

        console.log('Module configured, loading WASM...');
    </script>

    {{{ SCRIPT }}}
</body>
</html>
